/* $Id$ */

/* scan a symbol table generated by 'nm -f posix'.
 * It obeys the format:
 *
 * <library_name>'['<archive_member_name>']:'
 * <symbol_name>' '<class_char>' '[<start>' '<end>]
 */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <assert.h>
#include <search.h>

#define DEBUG

typedef struct ObjFRec_		*ObjF;
typedef struct SymRec_		*Sym;
typedef struct ExportRec_	*Export;
typedef struct ImportRec_	*Import;
typedef struct LinkRec_		*LinkSet;

typedef struct LinkRec {
	ObjF	anchor;
	ObjF	next;
} LinkRec;

typedef struct ObjFRec_ {
	char	*name;		/* name of this object file */
	ObjF	next;		/* linked list of all objects */
	LinkRec link; 		/* link set */
	ObjF	work;		/* temp pointer to do work */
	int		nexports;
	Export	exports;	/* symbols exported by this object */
	int		nimports;
	Import	imports;	/* symbols exported by this object */
} ObjFRec;

typedef struct SymRec_ {
	char	*name;
	Export	exportedBy;
	Import	importedFrom;
} SymRec;

typedef struct ExportRec_ {
	Sym			sym;
	ObjF		obj;
	unsigned	multiuse;	/* BITFIELD (assuming pointers are word aligned; LSB is 'weak' flag) */
} ExportRec;

typedef struct ImportRec_ {
	Sym		sym;
	ObjF	obj;
	Import	peer;	/* pointer to others importing this symbol */
} ImportRec;

#define EXPORT_FLAGS 	1
#define EXPORT_FLG_WEAK	1

#define EXPORT_NEXT(export) ((Export)((export)->multiuse & ~EXPORT_FLAGS))
#define EXPORT_WEAK(export) ((export)->multiuse & EXPORT_FLG_WEAK)

#define WARN_UNDEFINED_SYMS (1<<0)

#ifndef DEFAULT_WARN_FLAGS
#ifdef DEBUG
#define DEFAULT_WARN_FLAGS (-1)
#else
#define DEFAULT_WARN_FLAGS 0
#endif
#endif

static int warn = DEFAULT_WARN_FLAGS;

static inline void export_set_next(Export e, Export next)
{
	e->multiuse &= EXPORT_FLAGS;
	e->multiuse |= ((unsigned)next) & ~EXPORT_FLAGS;
}

static inline void export_set_weak(Export e, int weak)
{
	if (weak)
		e->multiuse |= EXPORT_FLG_WEAK;
	else
		e->multiuse &= ~EXPORT_FLG_WEAK;
}

typedef void (*DepWalkAction)(ObjF f, int depth, void *closure);

static void depwalk_rec(ObjF f, int depth);
void depwalk(ObjF f, DepWalkAction action, void *closure);
static void depPrint(ObjF f, int depth, void *closure);

#define STRCHUNK	10000

/* string space allocator */
char *stralloc(int len)
{
static char		*buf;
static int		avail=0;
char			*rval;

	assert(len<=STRCHUNK);

	if (len > avail) {
		avail = STRCHUNK;
		assert( buf=malloc(avail) );
	}

	rval   = buf;
	buf   += len;
	avail -= len;
	return rval;
}

#define MAXBUF	500

#define XFMT(m)	FMT(m)
#define FMT(max)	"%"#max"s%*[ \t]%c%*[^\n] \n"

#define THEFMT XFMT(MAXBUF)

ObjF fileListHead=0, fileListTail=0;

void *symTbl = 0;

static int
symcmp(const void *a, const void *b)
{
const Sym sa=(const Sym)a, sb=(const Sym)b;
	return strcmp(sa->name, sb->name);
}

static void
fixupObj(ObjF f)
{
Sym		sym;
Export	ex;
int		i;

	if ( !f )
		return;

	/* fixup export list; we can do this only after all reallocs have been performed */

	for (i=0, ex=f->exports; i<f->nexports; i++,ex++) {
		/* append to list of modules exporting this symbol */
		sym = ex->sym;
		if ( sym->exportedBy ) {
			Export etmp;
			for ( etmp = sym->exportedBy; EXPORT_NEXT(etmp); etmp=EXPORT_NEXT(etmp) )
			  	/* nothing else to do */;
				export_set_next(etmp, ex);
		} else {
			sym->exportedBy = ex;
		}
	}
}

int
scan_file(FILE *f)
{
char	buf[MAXBUF+1];
int		got;
char	type;
int		line=0;
ObjF	obj =0;
int		len;
int		weak;
Sym		nsym = 0,sym;
Sym		*found;

	/* tag end of buffer */
	buf[MAXBUF]='X';

	while ( EOF != (got = fscanf(f, THEFMT, buf, &type)) ) {
		line++;
		if ( !buf[MAXBUF] ) {
			fprintf(stderr,"Scanner buffer overrun\n");
			return -1;
		}
		switch (got) {
			default:
				fprintf(stderr,"Unable to read line %i (%i conversions of '%s')\n",line,got,THEFMT);
				return -1;

			case 1:
				len = strlen(buf);
				if ( ':' != buf[len-1] ) {
					fprintf(stderr,"<FILENAME> in line %i not ':' terminated - did you use 'nm -fposix?'\n", line);
					return -1;
				}
				fixupObj(obj);
				assert( obj = calloc(1, sizeof(*obj)) );

				/* build/copy name */
				assert( obj->name = malloc(len) );
				len--; /* strip trailing ':' */
				buf[len]=0;
				strcpy( obj->name, buf );

				/* append to list of objecs */
				if (fileListTail) {
					fileListTail->next = obj;
				} else {
					fileListHead = obj;
				}
				fileListTail = obj;

#ifdef DEBUG
				printf("In FILE: '%s'\n", buf);
#endif
			break;

			case 2:
				if (!obj) {
					fprintf(stderr,"Symbol without object file?? (line %i)\n",line);
					return -1;
				}

				if ( !nsym )
					assert( nsym = calloc(1,sizeof(*nsym)) );

				nsym->name = buf;

				assert( found = (Sym*) tsearch(nsym, &symTbl, symcmp) );
				if ( *found == nsym ) {
#ifdef DEBUG
					printf("Adding new symbol %s (found %p, sym %p)\n",(*found)->name, found, *found);
#endif
					nsym->name = stralloc(strlen(buf)+1);
					strcpy(nsym->name, buf);
					nsym = 0;
				} else {
#ifdef DEBUG
					printf("Found existing symbol %s (found %p, sym %p)\n",(*found)->name, found, *found);
#endif
				}
				sym = *found;

				weak = 0;

				switch ( type ) {
					default:
						fprintf(stderr,"Unknown symbol type '%c' (line %i)\n",type,line);
					return -1;

					case 'W':
					case 'V': weak = 1;
					case 'D':
					case 'T':
					case 'R':
							  {
							  Export ex;
							  obj->nexports++;
							  assert( obj->exports = realloc(obj->exports, sizeof(*obj->exports) * obj->nexports) );
							  ex = &obj->exports[obj->nexports - 1];
							  ex->sym = sym;
							  ex->obj = obj;
							  export_set_weak(ex,weak);
							  export_set_next(ex,0);
							  }
					break;

					case 'U':
							  {
							  Import im;
							  obj->nimports++;
							  assert( obj->imports = realloc(obj->imports, sizeof(*obj->imports) * obj->nimports) );
							  im = &obj->imports[obj->nimports - 1];
							  im->sym = sym;
							  im->obj = obj;
							  im->peer = 0;
							  }
					break;
				}
#ifdef DEBUG
				printf("\t%c %s\n",type,buf);
#endif
			break;
		}
	}
	fixupObj(obj);
	free(nsym);
	return 0;
}

/* semantics: caller must have asserted that
 * 'f' is not part of any linkset already
 * (f->link.anchor == 0).
 * Then, the caller sets f->link.anchor and
 * calls 'link' to perform a recursive link.
 *
 * If anchor is left == 0, no recursion will
 * be performed.
 */

int
link(ObjF f)
{
register int i;
register Import imp;

	for (i=0, imp=f->imports; i<f->nimports; i++, imp++) {
		register Sym *found;
		assert( 0 == imp->peer );
		assert (found = (Sym*)tfind( imp->sym, &symTbl, symcmp ));

		/* add ourself to the importers of that symbol */
		imp->peer = (*found)->importedFrom;
			(*found)->importedFrom =  imp;

		if ( !(*found)->exportedBy ) {
			if (warn & WARN_UNDEFINED_SYMS) {
				fprintf(stderr,
					"Warning: symbol %s:%s undefined\n",
					f->name, imp->sym->name);
			}
		} else {
			ObjF	dep= (*found)->exportedBy->obj;
			if ( f->link.anchor && !dep->link.anchor ) {
				f->link.next = dep;
				dep->link.anchor = f->link.anchor;
				link(dep);
			}
		}
	}
}

void
trackSym(Sym s)
{
Export ex;
Import imp;
	printf("What I know about Symbol '%s':\n", s->name);
	printf("  Defined in object: ");
	if ( ! (ex = s->exportedBy) ) {
		printf(" NOWHERE!!!\n");
	} else {
		printf("%s%s\n", ex->obj->name, EXPORT_WEAK(ex) ? " (WEAK)" : "");
		while ( ex=EXPORT_NEXT(ex) ) {
			printf("      AND in object: %s%s\n", ex->obj->name, EXPORT_WEAK(ex) ? " (WEAK)" : "");
		}
	}

	printf("  Needed by:");

	imp = s->importedFrom;

	if ( imp ) {
		printf("\n");
		do {
			depwalk(imp->obj, depPrint, 4);
		} while ( imp = imp->peer );
	} else {
		printf(" NOBODY - (no dependencies)\n");
	}
}

static DepWalkAction	depwalkAction = 0;
static void				*depwalkClosure =0;

/* walk all objects depending on this one */
static void
depwalk_rec(ObjF f, int depth)
{
register int	i;
register Import imp;

	if (depwalkAction)
		depwalkAction(f,depth,depwalkClosure);
	for ( i=0; i<f->nexports; i++ ) {
		for (imp = f->exports[i].sym->importedFrom; imp; imp = imp->peer) {
			if ( !imp->obj->work ) {
				/* mark in use */
				imp->obj->work = f;
				depwalk_rec(imp->obj, depth+1);
				imp->obj->work = 0;
			} /* else break circular dependency */
		}
	}
}

void
depwalk(ObjF f, DepWalkAction action, void *closure)
{
	f->work = (ObjF)1;
	depwalkAction  = action;
	depwalkClosure = closure;
	depwalk_rec(f, 0);
	f->work = 0;
}

static void
symTraceAct(const void *pnode, const VISIT when, const int depth)
{
	if ( postorder == when || leaf == when ) {
		trackSym(*(Sym*)pnode);
	}
}

int checkObjPtrs()
{
int		err=0;
ObjF	f;
	for (f=fileListHead; f; f=f->next) { 
		int ii;
		for (ii=0; ii<f->nexports; ii++) {
			if (f->exports[ii].obj != f) {
				printf("%s %ith export obj pointer corrupted\n", f->name, ii);
				err++;
			}
		}
		for (ii=0; ii<f->nimports; ii++) {
			if (f->imports[ii].obj != f) {
				printf("%s %ith import obj pointer corrupted\n", f->name, ii);
				err++;
			}
		}
	}
	return err;
}

void
depPrint(ObjF f, int d, void *closure)
{
int indent = (int)closure;
	d = (d<<2) + indent;
	while (d-- > 0) fputc(' ',stdout);
	printf("%s\n",f->name);
}

int
main(int argc, char **argv)
{
FILE	*feil=stdin;
ObjF	*sets=0;
ObjF	f;
int		nsets=0;
int		i;

	if (argc > 1) {
		if ( !(feil=fopen(argv[1],"r")) ) {
			perror("opening file");
			exit(1);
		}
	}

	if ( 0 == scan_file(feil) ) {
		assert( 0 == checkObjPtrs() );

		for (f=fileListHead; f; f=f->next) { 
			if (!f->link.anchor) {
				sets=realloc(sets,sizeof(*sets)*++nsets);
				sets[nsets-1]  = f;
				f->link.anchor = f;
				link(f);
			}
		}
	}

	for (i=0; i<nsets; i++) {
		for (f=sets[i]; f; f=f->link.next) {
			printf("%s  ",f->name);
		}
		printf("\n");
	}
	twalk(symTbl, symTraceAct);

	for (f=fileListHead; f; f=f->next) {
		printf("\n\nDependencies ON object: ");
		depwalk(f, depPrint, (void*)-4);
	}
	assert( 0 == checkObjPtrs() );
}
